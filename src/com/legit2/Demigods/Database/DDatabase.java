/*
	Copyright (c) 2013 The Demigods Team
	
	Demigods License v1
	
	This plugin is provided "as is" and without any warranty.  Any express or
	implied warranties, including, but not limited to, the implied warranties
	of merchantability and fitness for a particular purpose are disclaimed.
	In no event shall the authors be liable to any party for any direct,
	indirect, incidental, special, exemplary, or consequential damages arising
	in any way out of the use or misuse of this plugin.
	
	Definitions
	
	 1. This Plugin is defined as all of the files within any archive
	    file or any group of files released in conjunction by the Demigods Team,
	    the Demigods Team, or a derived or modified work based on such files.
	
	 2. A Modification, or a Mod, is defined as this Plugin or a derivative of
	    it with one or more Modification applied to it, or as any program that
	    depends on this Plugin.
	
	 3. Distribution is defined as allowing one or more other people to in
	    any way download or receive a copy of this Plugin, a Modified
	    Plugin, or a derivative of this Plugin.
	
	 4. The Software is defined as an installed copy of this Plugin, a
	    Modified Plugin, or a derivative of this Plugin.
	
	 5. The Demigods Team is defined as Alexander Chauncey and Alex Bennett
	    of http://www.clashnia.com/.
	
	Agreement
	
	 1. Permission is hereby granted to use, copy, modify and/or
	    distribute this Plugin, provided that:
	
	    a. All copyright notices within source files and as generated by
	       the Software as output are retained, unchanged.
	
	    b. Any Distribution of this Plugin, whether as a Modified Plugin
	       or not, includes this license and is released under the terms
	       of this Agreement. This clause is not dependant upon any
	       measure of changes made to this Plugin.
	
	    c. This Plugin, Modified Plugins, and derivative works may not
	       be sold or released under any paid license without explicit 
	       permission from the Demigods Team. Copying fees for the 
	       transport of this Plugin, support fees for installation or
	       other services, and hosting fees for hosting the Software may,
	       however, be imposed.
	
	    d. Any Distribution of this Plugin, whether as a Modified
	       Plugin or not, requires express written consent from the
	       Demigods Team.
	
	 2. You may make Modifications to this Plugin or a derivative of it,
	    and distribute your Modifications in a form that is separate from
	    the Plugin. The following restrictions apply to this type of
	    Modification:
	
	    a. A Modification must not alter or remove any copyright notices
	       in the Software or Plugin, generated or otherwise.
	
	    b. When a Modification to the Plugin is released, a
	       non-exclusive royalty-free right is granted to the Demigods Team
	       to distribute the Modification in future versions of the
	       Plugin provided such versions remain available under the
	       terms of this Agreement in addition to any other license(s) of
	       the initial developer.
	
	    c. Any Distribution of a Modified Plugin or derivative requires
	       express written consent from the Demigods Team.
	
	 3. Permission is hereby also granted to distribute programs which
	    depend on this Plugin, provided that you do not distribute any
	    Modified Plugin without express written consent.
	
	 4. The Demigods Team reserves the right to change the terms of this
	    Agreement at any time, although those changes are not retroactive
	    to past releases, unless redefining the Demigods Team. Failure to
	    receive notification of a change does not make those changes invalid.
	    A current copy of this Agreement can be found included with the Plugin.
	
	 5. This Agreement will terminate automatically if you fail to comply
	    with the limitations described herein. Upon termination, you must
	    destroy all copies of this Plugin, the Software, and any
	    derivatives within 48 hours.
 */

package com.legit2.Demigods.Database;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;

import com.google.common.base.Joiner;
import com.legit2.Demigods.DDivineBlocks;
import com.legit2.Demigods.Libraries.DCharacter;
import com.legit2.Demigods.Libraries.DivineBlock;
import com.legit2.Demigods.Utilities.DCharUtil;
import com.legit2.Demigods.Utilities.DConfigUtil;
import com.legit2.Demigods.Utilities.DDataUtil;
import com.legit2.Demigods.Utilities.DObjUtil;
import com.legit2.Demigods.Utilities.DPlayerUtil;
import com.legit2.Demigods.Utilities.DMiscUtil;

public class DDatabase
{
	/*
	 *  initializeDatabase() : Loads the MySQL or SQLite database.
	 */
	public static void initializeDatabase()
	{
		// Check if MySQL is enabled in the configuration and if so, attempts to connect.
		if(DConfigUtil.getSettingBoolean("database.mysql.use"))
		{
			DMySQL.createConnection();
			DMySQL.initializeMySQL();
			loadAllData();
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		else
		{
			// If nothing else works then use a FlatFile
			DFlatFile.load();
		}
	}

	/*
	 *  uninitializeDatabase() : Unloads the MySQL or SQLite database.
	 */
	public static void uninitializeDatabase()
	{
		saveAllData();
		
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{
			DMySQL.uninitializeMySQL();
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
	}

	/*
	 *  addPlayerToDB() : Adds the player to the database.
	 */
	public static void addPlayerToDB(OfflinePlayer player) throws SQLException
	{
		// Define variables
		Long firstLoginTime = System.currentTimeMillis();

		// Next we add them to the Database if needed
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{	
			int playerID = DPlayerUtil.getPlayerID(player);
			String playerName = player.getName();
			
			String addQuery = "INSERT INTO " + DMySQL.player_table + " (player_id, player_name, player_characters, player_kills, player_deaths, player_firstlogin, player_lastlogin) VALUES (" + playerID + ",'" + playerName + "', NULL, 0, 0," + firstLoginTime + "," + firstLoginTime +");";
			DMySQL.runQuery(addQuery);
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
	}
	
	/*
	 *  removePlayerFromDB() : Removes the player from the database.
	 */
	public static void removePlayerFromDB(OfflinePlayer player) throws SQLException
	{
		// Next we add them to the Database if needed
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{	
			// TODO: Remove player from MySQL
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
	}
	
	/*
	 *  addPlayerToDB() : Adds the player to the database.
	 */
	public static void addCharToDB(DCharacter character) throws SQLException
	{
		// Next we add them to the Database if needed
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{				
			int playerID = character.getOwnerID();
			int charID = character.getID();
			boolean charActive = character.isActive();
			String charName = character.getName();
			String charDeity = character.getDeity();
			String charAlliance = character.getAlliance();
			boolean charImmortal = character.isImmortal();
			int charHP = character.getHealth();
			float charExp = character.getExp();
			int charFavor = character.getFavor();
			int charMaxFavor = character.getMaxFavor();
			int charDevotion = character.getDevotion();
			int charAscensions = character.getAscensions();
			
			Location charLoc = character.getLastLocation();
			double charLastX = charLoc.getX();
			double charLastY = charLoc.getY();
			double charLastZ = charLoc.getZ();
			String charLastW = charLoc.getWorld().getName();
			
			String addQuery = 
					"INSERT INTO " + DMySQL.character_table +
					"(char_id,player_id,char_active,char_name,char_deity,char_alliance,char_immortal,char_hp,char_exp,char_favor,char_max_favor,char_devotion,char_ascensions,char_lastX,char_lastY,char_lastZ,char_lastW)" + 
					"VALUES (" +
						charID + "," +
						playerID + "," +
						charActive + "," +
						"'" + charName + "'," +
						"'" + charDeity + "'," +
						"'" + charAlliance + "'," +
						charImmortal + "," +
						charHP + "," +
						charExp + "," +
						charFavor + "," +
						charMaxFavor + "," +
						charDevotion + "," +
						charAscensions + "," +
						charLastX + "," +
						charLastY + "," +
						charLastZ + "," +
						"'" + charLastW + "'" +
					");";
			
			DMySQL.runQuery(addQuery);
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
	}

	/*
	 *  getPlayerInfo() : Grabs the player info from MySQL/FlatFile and returns (ResultSet)result.
	 */
	public static ResultSet getPlayerInfo(String username) throws SQLException
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{
			// TODO: Return player info from MySQL
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}

		return null;
	}
	
	/*
	 *  saveAllData() : Saves all HashMap data to database.
	 */
	public static boolean saveAllData()
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{	
			// Define variables
			int playerCount = 0;
			long startTimer = System.currentTimeMillis();
			
			// Save plugin-specific data
			savePlugin();
			long stopTimer = System.currentTimeMillis();
			double totalTime = (double) (stopTimer - startTimer);
			if(DConfigUtil.getSettingBoolean("data_debug")) DMiscUtil.info("Demigods plugin data saved in " + totalTime/1000 + " seconds.");
			else DMiscUtil.info("Demigods plugin data saved.");
					
			// Save divine blocks data
			saveDivineBlocks();
			
			for(Player player : DPlayerUtil.getOnlinePlayers())
			{
				if(savePlayer(player)) playerCount++;
			}

			// Stop the timer
			stopTimer = System.currentTimeMillis();
			totalTime = (double) (stopTimer - startTimer);

			// Send save success message
			if(DConfigUtil.getSettingBoolean("data_debug")) DMiscUtil.info("Success! Saved " + playerCount + " of " + DMySQL.getRows(DMySQL.runQuery("SELECT * FROM " + DMySQL.player_table + ";")) + " players in " + totalTime/1000 + " seconds.");
			else DMiscUtil.info("Success! Saved " + playerCount + " of " + DMySQL.getRows(DMySQL.runQuery("SELECT * FROM " + DMySQL.player_table + ";")) + " players.");
			return true;
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		else
		{
			// If nothing else works then use a FlatFile
			DFlatFile.save();
			return true;
		}
		return false;
	}
	
	/*
	 *  savePlayerData() : Saves all HashMap data for (OfflinePlayer)player to database.
	 */
	@SuppressWarnings("unchecked")
	public static boolean savePlayer(OfflinePlayer player)
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{			
			int playerID = DPlayerUtil.getPlayerID(player);

			// Clear tables first
			DMySQL.runQuery("DELETE FROM " + DMySQL.playerdata_table + " WHERE player_id=" + playerID);

			// Save their player-specific data
			HashMap<String, Object> allPlayerData = DDataUtil.getAllPlayerData(player);				
		
			// Define player-specific variables
			List<Integer> playerCharList = (List<Integer>) allPlayerData.get("player_characters");
			String playerChars;
			if(playerCharList != null) playerChars = Joiner.on(",").join(playerCharList);
			else playerChars = null;
			
			int playerKills = DObjUtil.toInteger(allPlayerData.get("player_kills"));
			int playerDeaths = DObjUtil.toInteger(allPlayerData.get("player_deaths"));
			Long playerLastLogin = (Long) allPlayerData.get("player_lastlogin");
			
			// Update main player table
			DMySQL.runQuery("UPDATE " + DMySQL.player_table + " SET player_characters='" + playerChars + "',player_kills=" + playerKills + ",player_deaths=" + playerDeaths + ",player_lastlogin=" + playerLastLogin + " WHERE player_id=" + playerID + ";");
			
			// Save miscellaneous player data
			DMySQL.runQuery("DELETE FROM " + DMySQL.playerdata_table + " WHERE player_id=" + playerID + ";");
			for(Entry<String, Object> playerData : allPlayerData.entrySet()) if(!playerData.getKey().contains("player_") && !playerData.getKey().contains("temp_")) DMySQL.runQuery("INSERT INTO " + DMySQL.playerdata_table + " (player_id, datakey, datavalue) VALUES(" + playerID + ",'" + playerData.getKey() + "','" + playerData.getValue() + "');");
			
			// Save their character-specific data now
			List<Integer> characters = DPlayerUtil.getChars(player);
			
			for(int charID : characters)
			{
				DCharacter character = DCharUtil.getChar(charID);
				
				// Define character-specific variables
				boolean charImmortal = character.isImmortal();
				int charHP = character.getHealth();
				float charExp = character.getExp();
				int charFavor = character.getFavor();
				int charMaxFavor = character.getMaxFavor();
				int charDevotion = character.getDevotion();
				int charAscensions = character.getAscensions();
				
				Location location = character.getLastLocation();
				Double charLastX = location.getX();
				Double charLastY = location.getY();
				Double charLastZ = location.getZ();
				String charLastW = location.getWorld().getName();
				
				// Update main character table
				DMySQL.runQuery("UPDATE " + DMySQL.character_table + " SET char_immortal=" + charImmortal + ",char_hp=" + charHP + ",char_exp=" + charExp + ",char_favor=" + charFavor + ",char_max_favor=" + charMaxFavor + ",char_devotion=" + charDevotion + ",char_ascensions=" + charAscensions + ",char_lastX=" + charLastX + ",char_lastY=" + charLastY + ",char_lastZ=" + charLastZ + ",char_lastW='" + charLastW + "'  WHERE char_id=" + charID + ";");

				// Save miscellaneous character data
				HashMap<String, Object> characterData = DDataUtil.getAllCharData(charID);
				DMySQL.runQuery("DELETE FROM " + DMySQL.chardata_table + " WHERE char_id=" + charID + ";");
				for(Entry<String, Object> charData : characterData.entrySet()) if(!charData.getKey().contains("char_")) DMySQL.runQuery("INSERT INTO " + DMySQL.chardata_table + " (char_id, datakey, datavalue) VALUES(" + charID + ",'" + charData.getKey() + "','" + charData.getValue() + "');");
			}
			return true;
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		return false;
	}
	
	/*
	 *  savePluginData() : Saves all HashMap data for the plugin to the database.
	 */
	public static boolean savePlugin()
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{			
			// Clear tables first
			DMySQL.runQuery("TRUNCATE TABLE " + DMySQL.plugindata_table + ";");

			// Save their player-specific data
			HashMap<String, HashMap<String, Object>> allPluginData = DDataUtil.getAllPluginData();				

			// Save data
			for(Entry<String, HashMap<String, Object>> pluginData : allPluginData.entrySet())
			{
				String dataID = pluginData.getKey();
				
				for(Entry<String, Object> data : pluginData.getValue().entrySet())
				if(!pluginData.getKey().contains("temp_"))
				{
					String dataKey = data.getKey();
					Object dataValue = data.getValue();
					
					DMySQL.runQuery("INSERT INTO " + DMySQL.plugindata_table + " (data_id, datakey, datavalue) VALUES('" + dataID + "','" + dataKey + "','" + dataValue + "');");
				}
			}
					
			return true;
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		return false;
	}
	
	/*
	 *  saveBlockData() : Saves all HashMap data for divine blocks to the database.
	 */
	public static boolean saveDivineBlocks()
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{			
			// Clear tables first
			DMySQL.runQuery("TRUNCATE TABLE " + DMySQL.divineblocks_table + ";");
			
			// Save data
			for(Entry<Integer, HashMap<String, Object>> divineBlock : DDataUtil.getAllBlockData().entrySet())
			{
				int blockID = divineBlock.getKey();
				DivineBlock block = (DivineBlock) divineBlock.getValue().get("block_object");
				
				if(!block.isPermanent()) continue;
				
				int blockParent = block.getParent();			
				String blockType = block.getType();
				String blockDeity = block.getDeity();
				double blockX = block.getX();
				double blockY = block.getY();
				double blockZ = block.getZ();
				String blockWorld = block.getWorld();

				DMySQL.runQuery("INSERT INTO " + DMySQL.divineblocks_table + " (block_id, block_parent, block_type, block_deity, block_x, block_y, block_z, block_world) VALUES(" + blockID + "," + blockParent + ",'" + blockType + "','" + blockDeity + "'," + blockX + "," + blockY + "," + blockZ + ",'" + blockWorld + "');");
			}
					
			return true;
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		return false;
	}
	
	/*
	 *  loadAllData() : Loads all data from database into HashMaps.
	 */
	public static void loadAllData()
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{	
			DMiscUtil.info("Loading Demigods data...");

			// Define variables
			int playerCount = 0;
			int characterCount = 0;
			int divineBlockCount = 0;
			long startStopwatch = System.currentTimeMillis();

			// Load Players
			ResultSet playerResult = DMySQL.runQuery("SELECT * FROM " + DMySQL.player_table + " LEFT JOIN " + DMySQL.playerdata_table + " ON " + DMySQL.player_table + ".player_id = " + DMySQL.playerdata_table + ".player_id;");
			try 
			{
				while(playerResult.next())
				{
					playerCount++;
					
					OfflinePlayer player = DPlayerUtil.definePlayer(playerResult.getString("player_name"));
					int playerID = playerResult.getInt("player_id");
					
					List<String> playerCharList;
					String playerChars = playerResult.getString("player_characters");
					if(playerChars != null) playerCharList = Arrays.asList(playerChars.split(","));
					else playerCharList = new ArrayList<String>();
					
					// Load the main player data
					DDataUtil.addPlayer(player, playerID);
					DDataUtil.savePlayerData(player, "player_id", playerResult.getInt("player_id"));
					DDataUtil.savePlayerData(player, "player_characters", playerCharList);
					DDataUtil.savePlayerData(player, "player_kills", playerResult.getInt("player_kills"));
					DDataUtil.savePlayerData(player, "player_deaths", playerResult.getInt("player_deaths"));
					DDataUtil.savePlayerData(player, "player_firstlogin", playerResult.getLong("player_firstlogin"));
				
					// Load other player data
					if(playerResult.getString("datakey") != null)
					{
						if(playerResult.getString("datakey").contains("boolean_")) DDataUtil.savePlayerData(player, playerResult.getString("datakey"), playerResult.getBoolean("datavalue"));
						else DDataUtil.savePlayerData(player, playerResult.getString("datakey"), playerResult.getString("datavalue"));
					}
				
					ResultSet charResult = DMySQL.runQuery("SELECT * FROM " + DMySQL.character_table + " LEFT JOIN " + DMySQL.chardata_table + " ON " + DMySQL.character_table + ".char_id = " + DMySQL.chardata_table + ".char_id AND " + DMySQL.character_table + ".player_id=" + playerID + ";");
					while(charResult.next())
					{
						characterCount++;
						
						// Define variables
						int charID = charResult.getInt("char_id");
						Location location = new Location(Bukkit.getWorld(charResult.getString("char_lastW")),  charResult.getDouble("char_lastX"),  charResult.getDouble("char_lastY"),  charResult.getDouble("char_lastZ"));
						
						DCharacter character = new DCharacter(player, charID, charResult.getString("char_name"), charResult.getString("char_deity"));
						character.setLocation(location);
						character.toggleActive(charResult.getBoolean("char_active"));
						character.toggleImmortal(charResult.getBoolean("char_immortal"));
						character.setHealth(charResult.getInt("char_hp"));
						character.setExp(charResult.getFloat("char_exp"));
						character.setFavor(charResult.getInt("char_favor"));
						character.setMaxFavor(charResult.getInt("char_max_favor"));
						character.setAscensions(charResult.getInt("char_ascensions"));
						character.setDevotion(charResult.getInt("char_devotion"));
						
						// Load other character data
						if(charResult.getString("datakey") != null)
						{
							if(charResult.getString("datakey").contains("boolean_")) DDataUtil.saveCharData(charID, charResult.getString("datakey"), charResult.getBoolean("datavalue"));
							else DDataUtil.saveCharData(charID, charResult.getString("datakey"), charResult.getString("datavalue"));
						}
					}
				}
				
				// Load Divine Blocks
				ResultSet divineBlocks = DMySQL.runQuery("SELECT * FROM " + DMySQL.divineblocks_table);
				
				int blockID = 0;
				
				while(divineBlocks.next())
				{
					divineBlockCount++;

					// Set data to variables
					blockID = divineBlocks.getInt("block_id");
					int parentID = divineBlocks.getInt("block_parent");
					String blockType = divineBlocks.getString("block_type");
					String blockDeity = divineBlocks.getString("block_deity");
					Location location = new Location(Bukkit.getWorld(divineBlocks.getString("block_world")), divineBlocks.getDouble("block_x"), divineBlocks.getDouble("block_y"), divineBlocks.getDouble("block_z"));

					DivineBlock block = new DivineBlock(location, blockID, parentID, true, blockType, blockDeity);
					DDataUtil.saveBlockData(blockID, "block_object", block);
					
					if(blockType.equalsIgnoreCase("altar")) DDivineBlocks.generateAltar(location, parentID);
				}
			}
			catch(SQLException e)
			{
				// There was an error with the SQL.
				DMiscUtil.severe("Error while loading Demigods data. (ERR: 1001)");
				e.printStackTrace();
			}
			
			// Stop the timer
			long stopStopwatch = System.currentTimeMillis();
			double totalTime = (double) (stopStopwatch - startStopwatch);
			
			// Send data load success message
			if(DConfigUtil.getSettingBoolean("data_debug")) DMiscUtil.info("Loaded data for " + playerCount + " players, " + characterCount + " characters, and " + divineBlockCount + " divine blocks in " + totalTime/1000 + " seconds.");
			else DMiscUtil.info("Loaded data for " + playerCount + " players, " + characterCount + " characters, and " + divineBlockCount + " divine blocks.");
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
	}
	
	/*
	 *  removePlayer() : Removes the player completely from the database.
	 */
	public static boolean removePlayer(OfflinePlayer player)
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{			
			int playerID = DPlayerUtil.getPlayerID(player);
			
			DMySQL.runQuery("DELETE FROM " + DMySQL.player_table + " WHERE player_id=" + playerID + ";");
			DMySQL.runQuery("DELETE FROM " + DMySQL.playerdata_table + " WHERE player_id=" + playerID + ";");
			DMySQL.runQuery("DELETE FROM " + DMySQL.character_table + " WHERE player_id=" + playerID + ";");
			
			return true;
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		return false;
	}
	
	/*
	 *  removeChar() : Removes the character completely from the database.
	 */
	public static boolean removeChar(int charID)
	{
		if(DConfigUtil.getSettingBoolean("database.mysql.use") && DMySQL.checkConnection())
		{						
			DMySQL.runQuery("DELETE FROM " + DMySQL.character_table + " WHERE char_id=" + charID + ";");
			DMySQL.runQuery("DELETE FROM " + DMySQL.chardata_table + " WHERE char_id=" + charID + ";");
			
			return true;
		}
		else if(DConfigUtil.getSettingBoolean("database.sqlite.use"))
		{
			// TODO: SQLite
		}
		return false;
	}
}